@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix lingua: <http://www.w3.org/2000/10/swap/lingua#>.
@prefix var: <http://www.w3.org/2000/10/swap/var#>.
@prefix : <#>.

:equal log:complement :notEqual .

:equal a log:SymmetricProperty .
:notEqual a log:SymmetricProperty .

# Test...

# Here _:implication1 is true, the conclusion is false, thus the premise
# can't be true (thus false)
_:implication1
    lingua:premise _:pre1 ;
    lingua:conclusion false .

_:pre1 log:closedBy <> .

# But in this case we create a premise is NOT { :A :notEqual :B }  
# which should be equal to :A :equal :B 
_:pre1 {
    :A :notEqual :B . # This is false
}

# START HACKING ...
_:hacking1 
    lingua:premise _:hprem1 ;
    lingua:conclusion _:hcon1 .

_:hprem1 log:closedBy <> .
_:hcon1 log:closedBy <> .

_:htemplate {
    var:S var:P var:O .   
}

_:htemplate log:closedBy <> .

_:hprem1 {
    var:Rule 
        lingua:premise var:Pre ;
        lingua:conclusion false .

    # TODO Want to use var:Pre here instead of _:pre1 but this doesn't work ?!
    #var:Pre lingua:graph var:PreGraph .
    _:pre1 lingua:graph var:PreGraph .

    var:Pre log:closedBy <> . # Required to match only graphs in this test file

    _:htemplate lingua:graph var:TemplateGraph .
    _:htemplate log:closedBy <> . # Required to match only graphs in this test file

    var:PreGraph log:equalTo var:TemplateGraph .
    var:P log:complement var:PComplement .
}

_:hcon1 {
    var:S var:PComplement var:O .
}

### END HACKING

# Test
:test 
    lingua:question _:question ;
    lingua:answer _:answer .

_:question log:closedBy <> .
_:answer log:closedBy <> .

_:question {
    :A :equal :B .
}

_:answer {
    :test :is true .
}
