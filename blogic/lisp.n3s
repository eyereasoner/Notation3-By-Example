@prefix : <urn:example:> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .

# Small demonstrator of a lispy kind of interpreter in blogic
# Here you can write a small program
:Prog1 :value
    (:car
        (:cdr 
            (:cons 
                 (:quote {:a a :b} ) ({ :a a :c })
            )
        )
    ) .

# This is to display the output of your program
(?S ?O) log:onQuerySurface {
    ?S :result ?O .
} .

# Test
( ?S) log:onNegativeSurface {
    ?S :result { :a a :c } .
    () log:onNegativeSurface {
        :test :is true .
    } .
} .

() log:onQuerySurface {
    :test :is true .
} .

# START BLOGIC Stuff------------------------------------------------------------
# This is still work in progress

# Compile
(?Name ?Prog ?Answer) log:onNegativeSurface {
    ?Name :value ?Prog .

    ?Prog :eval ?Answer .

    () log:onNegativeSurface {
        ?Name :result ?Answer .
    } .
} .

(?L1 ?L2 ?H ?R) log:onNegativeSurface {
    () log:onNegativeSurface <<?L1 :eval ?L2>> .

    ?L1 log:rawType rdf:List .

    # Calculate the H(ead) and R(est)
    ?L1 list:firstRest ( ?H ?R ) .

    ?H log:rawType log:Other .

    # Evaluate first the inner
    ?R ?H ?L2 .
} .

(?L1 ?L2 ?Type) log:onNegativeSurface {
    () log:onNegativeSurface <<?L1 :eval ?L2>> .
    ?L1 log:rawType ?Type .
    ?Type log:notEqualTo rdf:List .
    ?L1 log:equalTo ?L2 .
} .

(?L1 ?L2 ?H ?R ?Type) log:onNegativeSurface {
    () log:onNegativeSurface <<?L1 :eval ?L2>> .

    ?L1 log:rawType rdf:List .

    # Calculate the H(ead) and R(est)
    ?L1 list:firstRest ( ?H ?R ).

    ?H log:rawType ?Type .

    ?Type log:notEqualTo log:Other .

    ?L1 log:equalTo ?L2 .
} .

#############################################################
# "built-ins"                                               #
#############################################################

# :quote
(?L1 ?L2) log:onNegativeSurface {
    () log:onNegativeSurface <<(?L1) :quote ?L2>> .
    ?L1 log:equalTo ?L2 .
} .

# :atom
(?L1 ?X) log:onNegativeSurface {
    () log:onNegativeSurface <<?L1 :atom true>> .
    ?L1 :eval ?X .
    ?X log:rawType log:Formula . 
} .

(?L1 ?X ?Y) log:onNegativeSurface {
    () log:onNegativeSurface <<(?L1) :atom false>> .
    ?L1 :eval ?X .
    ?X log:rawType ?Y . 
    ?Y log:notEqualTo log:Formula .
} .

# :eq
(?L1 ?L2 ?X ?Y) log:onNegativeSurface {
    () log:onNegativeSurface <<(?L1 ?L2) :eq true>> .
    ?L1 :eval ?X .
    ?L2 :eval ?Y .
    ?X :atom true .
    ?X log:equalTo ?Y .
} .

(?L1 ?L2 ?X ?Y) log:onNegativeSurface {
    () log:onNegativeSurface <<(?L1 ?L2) :eq false>> .
    ?L1 :eval ?X .
    ?L2 :eval ?Y .
    ?X :atom false .
} .

(?L1 ?L2 ?X ?Y) log:onNegativeSurface {
    () log:onNegativeSurface <<(?L1 ?L2) :eq false>> .
    ?L1 :eval ?X .
    ?L2 :eval ?Y .
    ?X log:notEqualTo ?Y .
} .

# :car
(?L1 ?L2 ?X) log:onNegativeSurface {
    () log:onNegativeSurface <<(?L1) :car ?L2>> .
    ?L1 :eval ?X .
    ?X list:first ?L2 .
} .

# :cdr
(?L1 ?X ?Y ?L2) log:onNegativeSurface {
    () log:onNegativeSurface <<(?L1) :cdr ?L2>> .
    ?L1 :eval ?X .

    ?X list:firstRest ( ?Y ?L2 ) .
} .

# :cons
(?L1 ?X ?Y ?L2 ?L3) log:onNegativeSurface {
    () log:onNegativeSurface <<(?L1 ?L2) :cons ?L3>> .
    ?L1 :eval ?X .
    ?L2 :eval ?Y .
    ( (?X) ?Y ) list:append ?L3 .
} .

# END BLOGIC Stuff--------------------------------------------------------------
