@prefix : <urn:example:> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .

# Small demonstrator of a lispy kind of interpreter in blogic
# Here you can write a small program
:Prog1 :value
    (:car
        (:cdr 
            (:cons 
                 (:quote {:a a :b} ) ({ :a a :c })
            )
        )
    ) .

# This is to display the output of your program
(_S _O) log:onQuerySurface {
    _S :result _O .
} .

# Test
( _S) log:onNegativeSurface {
    _S :result { :a a :c } .
    () log:onNegativeSurface {
        :test :is true .
    } .
} .

() log:onQuerySurface {
    :test :is true .
} .

# START BLOGIC Stuff------------------------------------------------------------
# This is still work in progress

# Compile
(_Name _Prog _Answer) log:onNegativeSurface {
    _Name :value _Prog .

    _Prog :eval _Answer .

    () log:onNegativeSurface {
        _Name :result _Answer .
    } .
} .

(_L1 _L2 _H _R) log:onNegativeSurface {
    () log:onNegativeSurface <<_L1 :eval _L2>> .

    _L1 log:rawType rdf:List .

    # Calculate the H(ead) and R(est)
    _L1 list:firstRest ( _H _R ) .

    _H log:rawType log:Other .

    # Evaluate first the inner
    _R _H _L2 .
} .

(_L1 _L2 _Type) log:onNegativeSurface {
    () log:onNegativeSurface <<_L1 :eval _L2>> .
    _L1 log:rawType _Type .
    _Type log:notEqualTo rdf:List .
    _L1 log:equalTo _L2 .
} .

(_L1 _L2 _H _R _Type) log:onNegativeSurface {
    () log:onNegativeSurface <<_L1 :eval _L2>> .

    _L1 log:rawType rdf:List .

    # Calculate the H(ead) and R(est)
    _L1 list:firstRest ( _H _R ).

    _H log:rawType _Type .

    _Type log:notEqualTo log:Other .

    _L1 log:equalTo _L2 .
} .

#############################################################
# "built-ins"                                               #
#############################################################

# :quote
(_L1 _L2) log:onNegativeSurface {
    () log:onNegativeSurface <<(_L1) :quote _L2>> .
    _L1 log:equalTo _L2 .
} .

# :atom
(_L1 _X) log:onNegativeSurface {
    () log:onNegativeSurface <<_L1 :atom true>> .
    _L1 :eval _X .
    _X log:rawType log:Formula . 
} .

(_L1 _X _Y) log:onNegativeSurface {
    () log:onNegativeSurface <<(_L1) :atom false>> .
    _L1 :eval _X .
    _X log:rawType _Y . 
    _Y log:notEqualTo log:Formula .
} .

# :eq
(_L1 _L2 _X _Y) log:onNegativeSurface {
    () log:onNegativeSurface <<(_L1 _L2) :eq true>> .
    _L1 :eval _X .
    _L2 :eval _Y .
    _X :atom true .
    _X log:equalTo _Y .
} .

(_L1 _L2 _X _Y) log:onNegativeSurface {
    () log:onNegativeSurface <<(_L1 _L2) :eq false>> .
    _L1 :eval _X .
    _L2 :eval _Y .
    _X :atom false .
} .

(_L1 _L2 _X _Y) log:onNegativeSurface {
    () log:onNegativeSurface <<(_L1 _L2) :eq false>> .
    _L1 :eval _X .
    _L2 :eval _Y .
    _X log:notEqualTo _Y .
} .

# :car
(_L1 _L2 _X) log:onNegativeSurface {
    () log:onNegativeSurface <<(_L1) :car _L2>> .
    _L1 :eval _X .
    _X list:first _L2 .
} .

# :cdr
(_L1 _X _Y _L2) log:onNegativeSurface {
    () log:onNegativeSurface <<(_L1) :cdr _L2>> .
    _L1 :eval _X .

    _X list:firstRest ( _Y _L2 ) .
} .

# :cons
(_L1 _X _Y _L2 _L3) log:onNegativeSurface {
    () log:onNegativeSurface <<(_L1 _L2) :cons _L3>> .
    _L1 :eval _X .
    _L2 :eval _Y .
    ( (_X) _Y ) list:append _L3 .
} .

# END BLOGIC Stuff--------------------------------------------------------------
