@prefix : <urn:example:> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .

# Alice is on the implicit postive surface
:Alice :knows :Bob.

# Bob is on a new positive surface
#   .. but when reasoning about surfaces this
#   should be interpreted as a conjunction 
#   with Alice's statement.
() log:onPositiveSurface {
    :Bob :knows :Charly .
} .

# If X knows Y, then X,Y is knowable
(?S ?O) log:onNegativeSurface {

    # We add the premise on a postive
    # surface .. it is not strictly needed 
    # because the implicit surface is positive
    #   () log:onNegativeSurface {  <-- this part here is implicit positive --> }
    # This also means that
    #   () log:onNegativeSurface {}
    # is a contradiction because a positive empty surface {} is a 'true'
    () log:onPositiveSurface {
        ?S :knows ?O .
    } .

    () log:onNegativeSurface {
        ?S :isKnowable true .
        ?O :isKnowable true .
    } .
} .

# Here we implement a broken rule, we add graffiti
# on the positive surface to block the scope of the variables
(?S ?O) log:onNegativeSurface {
    # Write for ?S and ?O new grafiti ..
    (?S ?O) log:onPositiveSurface {
        ?S :knows ?O .
    } .
    () log:onNegativeSurface {
        ?S :hates ?O .
    } .
} .

(?S) log:onQuerySurface {
    ?S :isKnowable true .
} .

# Test 
# See the noGod example why this works...
() log:onPositiveSurface {
    [] :hates [] .

    (?Counter ?S ?O) log:onNegativeSurface {
        :Alice :isKnowable true .
        :Bob :isKnowable true .
        :Charly :isKnowable true .

        # There shouldn't be any extra hates
        ?Counter a log:GraphCounter .
        { ?S :hates ?O } ?Counter 1.

        () log:onNegativeSurface {
            :test :is true .
        } .
    } .
} .

# Add a counter
:cardinalCount a log:GraphCounter .
(?Graph ?Count ?List ?Scope) log:onNegativeSurface {
    () log:onNegativeSurface <<?Graph :cardinalCount ?Count>> .
    ( () ?Graph ?List ) log:collectAllIn ?Scope .
    ?List list:length ?Count .
} .

() log:onQuerySurface {
    :test :is true .
} .
