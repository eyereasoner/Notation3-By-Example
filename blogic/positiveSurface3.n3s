@prefix : <urn:example:> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .

# Alice is on the implicit postive surface
:Alice :knows :Bob.

# Bob is on a new positive surface
#   .. but when reasoning about surfaces this
#   should be interpreted as a conjunction 
#   with Alice's statement.
() log:onPositiveSurface {
    :Bob :knows :Charly .
} .

# If X knows Y, then X,Y is knowable
(_S _O) log:onNegativeSurface {

    # We add the premise on a postive
    # surface .. it is not strictly needed 
    # because the implicit surface is positive
    #   () log:onNegativeSurface {  <-- this part here is implicit positive --> }
    # This also means that
    #   () log:onNegativeSurface {}
    # is a contradiction because a positive empty surface {} is a 'true'
    () log:onPositiveSurface {
        _S :knows _O .
    } .

    () log:onNegativeSurface {
        _S :isKnowable true .
        _O :isKnowable true .
    } .
} .

# Here we implement a broken rule, we add graffiti
# on the positive surface to block the scope of the variables
(_S _O) log:onNegativeSurface {
    # Write for _S and _O new grafiti ..
    (_S _O) log:onPositiveSurface {
        _S :knows _O .
    } .
    () log:onNegativeSurface {
        _S :hates _O .
    } .
} .

(_S) log:onQuerySurface {
    _S :isKnowable true .
} .

# Test 
# See the noGod example why this works...
() log:onPositiveSurface {
    [] :hates [] .

    (_Counter _S _O) log:onNegativeSurface {
        :Alice :isKnowable true .
        :Bob :isKnowable true .
        :Charly :isKnowable true .

        # There shouldn't be any extra hates
        _Counter a log:GraphCounter .
        { _S :hates _O } _Counter 1.

        () log:onNegativeSurface {
            :test :is true .
        } .
    } .
} .

# Add a counter
:cardinalCount a log:GraphCounter .
(_Graph _Count _List _Scope) log:onNegativeSurface {
    () log:onNegativeSurface <<_Graph :cardinalCount _Count>> .
    ( () _Graph _List ) log:collectAllIn _Scope .
    _List list:length _Count .
} .

() log:onQuerySurface {
    :test :is true .
} .
