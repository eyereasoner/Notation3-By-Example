@prefix : <urn:example:> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

# Demonstration of the query surface
:Alice a :Person .

# Return Alice to an external process
() log:onQuerySurface {
    :Alice a :Person .
} .

:Someone a :Person .

# Use a blank node a universal
(_S) log:onQuerySurface {
    _S a :Person .
} .

() log:onMySurface1 {
    :Bob a :Person .
} .

# Return from a surface 
(_S) log:onQuerySurface {
    () log:onMySurface1 {
        _S a :Person .
    } .
} .

() log:onMySurface2 {
    :Charly a :Person .
    :Daisy a :Person .
} .

# This will not work
() log:onQuerySurface {
    () log:onMySurface2 {
        :Charly a :Person .
    } .
} .

() log:onMySurface3 {
    :Charly a :Person .
    :Daisy a :Person .
} .

# This will work , but includes Charly and Daisy
(_G) log:onQuerySurface {
    () log:onMySurface3 _G .
} .

() log:onMySurface4 {
    :Alice a :Person .
    :Charly a :Cat .
} .

# Only show the surface which contains a cat
(_G _S) log:onQuerySurface {
    () log:onMySurface4 _G .
    _G log:includes { _S a :Cat } .
} .

() log:onMySurface5 {
    :Alice a :Person  .
    :Bob a :Person .
    :Charly a :Cat .
} .

() log:onMySurface5 {
    :Daisy a :Person  .
} .

# Query surfaces can also be a result of a rule
(_G _S) log:onNegativeSurface {
    () log:onMySurface5 _G .
    _G log:includes { _S a :Cat } .

    () log:onNegativeSurface {
        () log:onQuerySurface {
            () log:onMySurface5 _G .
        } .
    } .
} .

# This trick can be used to filter out only the things that 
# are of your interest
(_G _S1 _S2) log:onNegativeSurface {
    () log:onMySurface5 _G .
    _G log:includes { _S1 a :Person } .
    _G log:includes { _S2 a :Cat } .

    () log:onNegativeSurface {
        () log:onMyResultSurface {
            _S1 a :Person .
        } .

        (_X) log:onQuerySurface {
            () log:onMyResultSurface _X .
        } .
    } .
} .

# Make the ./make_example.sh happy
:test :is true .
() log:onQuerySurface {
    :test :is true .
} .
