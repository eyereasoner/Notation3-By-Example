@prefix : <urn:example:> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

# Demonstration of the query surface
:Alice a :Person .

# Return Alice to an external process
() log:onQuerySurface {
    :Alice a :Person .
} .

:Someone a :Person .

# Use a blank node a universal
(?S) log:onQuerySurface {
    ?S a :Person .
} .

() log:onMySurface1 {
    :Bob a :Person .
} .

# Return from a surface 
(?S) log:onQuerySurface {
    () log:onMySurface1 {
        ?S a :Person .
    } .
} .

() log:onMySurface2 {
    :Charly a :Person .
    :Daisy a :Person .
} .

# This will not work
() log:onQuerySurface {
    () log:onMySurface2 {
        :Charly a :Person .
    } .
} .

() log:onMySurface3 {
    :Charly a :Person .
    :Daisy a :Person .
} .

# This will work , but includes Charly and Daisy
(?G) log:onQuerySurface {
    () log:onMySurface3 ?G .
} .

() log:onMySurface4 {
    :Alice a :Person .
    :Charly a :Cat .
} .

# Only show the surface which contains a cat
(?G ?S) log:onQuerySurface {
    () log:onMySurface4 ?G .
    ?G log:includes { ?S a :Cat } .
} .

() log:onMySurface5 {
    :Alice a :Person  .
    :Bob a :Person .
    :Charly a :Cat .
} .

() log:onMySurface5 {
    :Daisy a :Person  .
} .

# Query surfaces can also be a result of a rule
(?G ?S) log:onNegativeSurface {
    () log:onMySurface5 ?G .
    ?G log:includes { ?S a :Cat } .

    () log:onNegativeSurface {
        () log:onQuerySurface {
            () log:onMySurface5 ?G .
        } .
    } .
} .

# This trick can be used to filter out only the things that 
# are of your interest
(?G ?S1 ?S2) log:onNegativeSurface {
    () log:onMySurface5 ?G .
    ?G log:includes { ?S1 a :Person } .
    ?G log:includes { ?S2 a :Cat } .

    () log:onNegativeSurface {
        () log:onMyResultSurface {
            ?S1 a :Person .
        } .

        (?X) log:onQuerySurface {
            () log:onMyResultSurface ?X .
        } .
    } .
} .

# Make the ./make_example.sh happy
:test :is true .
() log:onQuerySurface {
    :test :is true .
} .
