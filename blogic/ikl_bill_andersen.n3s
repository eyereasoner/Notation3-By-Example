@prefix : <urn:example:> .
@prefix owl: <http://www.w3.org/2002/07/owl#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#> .

# Inspired from https://www.jfsowa.com/ikl/iklguide.htm

# We have bill that believes something, he knows that an iranian has three planes
# or has some information about it..but doesn't know if these planes are the same
# (this is what an existential quantified \Exists: x,y,z does
:BillAndersen :believes {
    _S a :Iranian .
    _S :customer "Bank Melli Iran" .
    _S :owns _A1 , _A2 , _A3 .
    _A1 a :Airplane .
    _A2 a :Airplane .
    _A3 a :Airplane .
} .

_A2 :seenIn :Austria .

(_X _Y _S _A) log:onNegativeSurface {
    _X :believes _Y .

    # Make Bill's believe true
    _Y log:includes {
        _S :owns _A 
    } .

    _A :seenIn :Austria .

    # It could still be the case that all planes are equal
    _A log:isomorphic _A1 .

    () log:onNegativeSurface {
        :test :is true .
    } .
} .

() log:onQuerySurface {
    :test :is true .
} .

# sameAs: all properties of A are in B
(_A _B _C _D) log:onNegativeSurface {
    _A owl:sameAs _B .
    _A _C _D .
    () log:onNegativeSurface {
        _B _C _D .
    } .
} .

# sameAs: all subjects and objects of A as property also go for B as property
(_A _B _C _D) log:onNegativeSurface {
    _A owl:sameAs _B .
    _C _A _D .
    () log:onNegativeSurface {
        _C _B _D .
    } .
} . 

# sameAs: interchanging A and B as object has no effect 
(_A _B _C _D) log:onNegativeSurface {
    _A owl:sameAs _B .
    _D _C _A .
    () log:onNegativeSurface {
        _D _C _B .
    } .
} .

(_A _B) log:onNegativeSurface {
    _A owl:sameAs _B .
    () log:onNegativeSurface {
        _B owl:sameAs _A .
    } .
} .

(_A _B _C) log:onNegativeSurface {
    _A owl:sameAs _B .
    _B owl:sameAs _C .
    () log:onNegativeSurface {
        _A owl:sameAs _C .
    } .
} .