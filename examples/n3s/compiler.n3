@prefix : <https://github.com/eyereasoner/Notation3-By-Example/example/n3s#> .
@prefix q: <https://github.com/eyereasoner/Notation3-By-Example/example/n3q#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix graph: <http://www.w3.org/2000/10/swap/graph#> .

# Main rule which defined the :implies
(?A ?C ?X ?Xp ?Y ?Yp ?Ypbn ?Ypvar ?CNew) log:onNegativeSurface {
    ?A :implies ?C .

    # Translated qvars to blank nodes
    #  Xp will contain a unique list of blank nodes
    #  X will be the translated formula
    ?A :qvar2bn (?Xp ?X).
    ?C :qvar2bn (?Yp ?Y).

    # Bn blank nodes are rewritten blank nodes in the original formula
    # We scope these flagged blank nodes to create the consequent of a rule
    # E.g. when
    #      { ?X a :Cat } :implies { ?X a :Feline }
    # we need to construct something like
    #    (genid:t_0-bn) log:onNegativeSurface  {
    #          genid_t_0-bn a :Cat .
    #          ( genid:t_1-bn ) log:onNegativeSurface {
    #               genid:t_1-bn a :Feline .
    #           }
    #     } .
    # All var-skolems are removed from the consequent graffiti the
    # var-skolem references in the consequent should refer to the
    # var-skolem graffiti in the outermost negative surface.
    # E.g. when
    #     { q:X a :Cat } :implies { q:X a :Feline }
    # we need to construct something like
    #    (genid:t_0-var) log:onNegativeSurface  {
    #        genid:t_0-var a :Cat .
    #        () log:onNegativeSurface {
    #            genid:t_0-var a :Feline .
    #        } .
    #    } .
    ( ?Yp :isSkolemBlank true ) :filter ?Ypbn .

    # Ypp is the scoping part of blank nodes
    ( ?X
      { ?Ypbn log:onNegativeSurface ?Y }
    ) graph:union ?CNew .

    () log:onNegativeSurface {
        ?Xp log:onNegativeSurface ?CNew .
        ?Yp log:onQuerySurface ?Y .
    } .
} .

##################################################################

# X :qvar2 (Y Z)
# qvars to blank node translation
#   X a formula with possible n3q 'variables' (q:)
#   Y a list of blank nodes
#   Z a formula only containing blank nodes
#
# E.g.
#    { q:X a q:Y } :qvar2 ( (genid:t0 genid:t1) { genid:t0 a genid:t1} ) .
(?X ?Y ?Z ?T1 ?T2 ?L) log:onNegativeSurface {
    () log:onNegativeSurface <<?X :qvar2bn (?Y ?Z)>> .
    ?X graph:list ?L .
    ( ?X ?L () () ) :_qvar2bn (?T1 ?T2) .
    ?T2 list:unique ?Y .
    ?Z graph:list ?T1 .
} .

(?Formula ?Acc1 ?Acc2 ) log:onNegativeSurface {
    () log:onNegativeSurface <<(?Formula () ?Acc1 ?Acc2) :_qvar2bn (?Acc1 ?Acc2)>> .
} .

(
    ?Formula
    ?L ?X ?Acc1 ?Acc2
    ?Acc1New ?Acc2New ?Acc2S ?Acc2P
    ?N ?H ?T
    ?S ?P ?O
    ?Sv ?Pv ?Ov
    ?Scope
) log:onNegativeSurface {
    () log:onNegativeSurface <<(?Formula ?L ?Acc1 ?Acc2) :_qvar2bn ?X>> .
    ?L log:rawType rdf:List .
    ?L list:length ?N .
    ?N math:greaterThan 0 .

    ?L list:firstRest (?H ?T) .

    ?H log:includes { ?S ?P ?O } .

    (?Formula ?S) :skolemize ?Sv .
    (?Formula ?P) :skolemize ?Pv .
    (?Formula ?O) :skolemize ?Ov .

    # If the S changed into a skolem, add it to the list of blank nodes
    (
        { ?S log:equalTo ?Sv }
        { ?Acc2 log:equalTo ?Acc2S }
        { (?Acc2 (?Sv)) list:append ?Acc2S }
    ) log:ifThenElseIn ?Scope .

    # If the P changed into a skolem, add it to the list of blank nodes
    (
        { ?P log:equalTo ?Pv }
        { ?Acc2S log:equalTo ?Acc2P }
        { (?Acc2S (?Pv)) list:append ?Acc2P }
    ) log:ifThenElseIn ?Scope .

    # If the O changed into a skolem, add it to the list of blank nodes
    (
        { ?O log:equalTo ?Ov }
        { ?Acc2P log:equalTo ?Acc2New }
        { (?Acc2P (?Ov)) list:append ?Acc2New }
    ) log:ifThenElseIn ?Scope .

    ( ?Acc1 ({ ?Sv ?Pv ?Ov }) ) list:append ?Acc1New .

    ( ?Formula ?T ?Acc1New ?Acc2New ) :_qvar2bn ?X .
} .

##################################################################

# (Formula X) :skolemize Y
# Turn a qvar into a skolemized version
# Turn a blank node into a 'flagged' skolemized version
#    Formula - a context formula for which a variable needs to be skolemized
#    X - a qvar or blank node variable
#    Y - the skolemized version of the variable
(?Formula ?Y ?X ?Xn ?Xnp ?Scope) log:onNegativeSurface {
    () log:onNegativeSurface <<(?Formula ?X) :skolemize ?Y>> .

    (
        # If we get a n3q variable, equivalent of a qvar (?x) in notation3....
        {
            ?X log:namespace ?Xn .
            ?Xn log:equalTo "https://github.com/eyereasoner/Notation3-By-Example/example/n3q#" .
        }
        # ... then turn it into a skolem variable
        {
            ?X :skolemVar ?Y .
        }
        # ... otherwise
        {
            # If we got a blank node, write it into a bn skolem
            # to trigger generating a universal in :_qvar2bn
            (
                {
                    ?X :isSkolem true .
                }
                {
                    # Rewrite the skolem to trigger creating a universal
                    # Add the context formula to trigger a new blank node
                    # for every new quoted graph..
                    (?Formula ?X) :skolemBlank ?Y .
                }
                {
                    ?X log:equalTo ?Y .
                }
            ) log:ifThenElseIn ?Scope .
        }
    ) log:ifThenElseIn ?Scope .
} .

##################################################################

# X :isSkolem true
# Holds when X is a skolem
#   X - a resource
#   Y - true when X a skolem, var skolem or bn skolem
# E.g.
#       genid:t_0 :isSkolem true
#       genid:t_1-var :isSkolem true
#       genid:t_1-dn :isSkolem true
(?X ?Xn) log:onNegativeSurface {
    () log:onNegativeSurface <<?X :isSkolem true>> .
    ?X log:namespace ?Xn .
    ?Xn string:contains ".well-known/genid/" .
} .

##################################################################

# X :skolemVar Y
# Turn X into a var skolem Y (qvar equivalent ?Y)
#   X a resource
#   Y a var skolem
# E.g.
#      q:X :skolemVar genid:t_0-var
(?X ?Y ?T1 ?T2 ?T3) log:onNegativeSurface {
    () log:onNegativeSurface <<?X :skolemVar ?Y>> .
    ?X log:skolem ?T1 .
    ?T1 log:uri ?T2 .
    ( ?T2 "-var" ) string:concatenation ?T3 .
    ?Y log:uri ?T3 .
} .

##################################################################

# X :skolemBlank Y
# Turn X into a flagged bn skolem Y (blank node equivalent ?Y)
#   X a resource
#   Y a bn skolem
# E.g.
#       ?X :skolemBlank genid:t_1-bn
(?X ?Y ?T1 ?T2 ?T3) log:onNegativeSurface {
    () log:onNegativeSurface <<?X :skolemBlank ?Y>> .
    ?X log:skolem ?T1 .
    ?T1 log:uri ?T2 .
    ( ?T2 "-bn" ) string:concatenation ?T3 .
    ?Y log:uri ?T3 .
} .

##################################################################

# X :isSkolemBlank Y
# Test if X is a bn skolem
#   X a variable
#   Y a boolean
# E.g.
#       genid:t_1-bn :isSkolemBlank true
#       genid:t_0-var :isSkolemBlank false
(?X ?Y ) log:onNegativeSurface {
    () log:onNegativeSurface <<?X :isSkolemBlank ?Y>> .
    (?X "-bn") :isSkolemOfType ?Y .
} .

# X :isSkolemVar Y
# Test if X is a bn skolem
#   X a variable
#   Y a boolean
# E.g.
#       genid:t_1-bn :isSkolemBlank false
#       genid:t_0-var :isSkolemBlank true
(?X ?T1 ?Y ?Scope) log:onNegativeSurface {
    () log:onNegativeSurface <<?X :isSkolemVar ?Y>> .
    (?X "-var") :isSkolemOfType ?Y .
} .

# Helper function for :isSkolemBlank :isSkolemVar
(?X ?Type ?T1 ?Y ?Scope) log:onNegativeSurface {
    () log:onNegativeSurface <<(?X ?Type) :isSkolemOfType ?Y>> .
    ?X log:uri ?T1 .
    (
        {
            ?T1 string:contains ".well-known/genid/" .
            ?T1 string:endsWith ?Type .
        }
        {
            ?Y log:equalTo true .
        }
        {
            ?Y log:equalTo false .
        }
    ) log:ifThenElseIn ?Scope .
} .

##################################################################

# ( X F FV) :filter Y
# Filter a list X with a built-in value into Y using
#     Xi element X : triple Xi F FV holds
# with
#     F  a built-in (or backward rule)
#     FV a
#
# E.g.
#       ( (1 2 4 8 16) math:greaterThan 4) :filter (8 16)
(?X ?F ?FV ?Y) log:onNegativeSurface {
    () log:onNegativeSurface <<(?X ?F ?FV) :filter ?Y>> .
    (?X ?F ?FV ()) :_filter ?Y .
} .

(?F ?FV ?Acc) log:onNegativeSurface {
    () log:onNegativeSurface <<( () ?F ?FV ?Acc ) :_filter ?Acc>> .
} .

(?X ?F ?FV ?Acc ?Y ?H ?T ?N ?AccNew ?Scope) log:onNegativeSurface {
    () log:onNegativeSurface <<( ?X ?F ?FV ?Acc ) :_filter ?Y>> .

    ?X log:rawType rdf:List .
    ?X list:length ?N .
    ?N math:greaterThan 0 .

    ?X list:firstRest (?H ?T) .

    (
        { ?H ?F ?FV }
        {
            ( ?Acc (?H)) list:append ?AccNew .
        }
        {
            ?Acc log:equalTo ?AccNew .
        }
    ) log:ifThenElseIn ?Scope .

    ( ?T ?F ?FV ?AccNew ) :_filter ?Y .
} .

##################################################################

# Debug
(?S ?O) log:onQuerySurface {
    ?S log:onNegativeSurfaceTest ?O .
} .

(?S ?O) log:onQuerySurface {
    ?S log:onQuerySurfaceTest ?O .
} .

##################################################################
