@prefix : <urn:example:> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix graph: <http://www.w3.org/2000/10/swap/graph#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .

# ( A Odd) asModal B
# Replace all nested surfaces into negative or modal according to the 
# nesting levels
#   A a graph
#   Odd true|false
#   B a graph with modals/negatives replaced
(_G1 _G1L _E _G2 _G2L) log:onNegativeSurface {
    () log:onNegativeSurface <<(_G1 _E) :asModal _G2>> .

    _G1 graph:list _G1L .

    # Creata an accumulator
    (_G1L _E ()) :asModal_ _G2L .

    _G2 graph:list _G2L .
} .

# We are done when the input is empty
(_E _Acc) log:onNegativeSurface {
    () log:onNegativeSurface <<(() _E _Acc) :asModal_ _Acc>> .
} .

# Process Odd = true
(_E _Acc _AccNew _Lin _Lout _H _T _X _G _GN _Scope _HN) log:onNegativeSurface {
    () log:onNegativeSurface <<(_Lin _E _Acc) :asModal_ _Lout>> .

    _Lin list:firstRest (_H _T) .

    # Odd is true
    _E log:equalTo true .

    (
        # If we have a modal surface
        { 
            _H log:includes { _X log:onModalSurface _G } .
            # Do the nested surfaces too
            ( _G false ) :asModal _GN .
        }
        # Then turn it into a negative surface
        { _HN log:equalTo { _X log:onNegativeSurface _GN } }
        # Else keep the triple
        { _HN log:equalTo _H }
    ) log:ifThenElseIn _Scope .

    ( _Acc ( _HN ) ) list:append _AccNew .

    (_T true _AccNew) :asModal_ _Lout .
} .

# Process Odd = false
(_E _Acc _AccNew _Lin _Lout _H _T _X _G _G2 _GN _Scope _HN) log:onNegativeSurface {
    () log:onNegativeSurface <<(_Lin _E _Acc) :asModal_ _Lout>> .

    _Lin list:firstRest (_H _T) .

    # Odd is true
    _E log:equalTo false .

    (
        # If we have a negative surface
        { 
            _H log:includes { _X log:onNegativeSurface _G } .
            # Do the nested surfaces too
            ( _G true ) :asModal _GN .    
        }
        # Then turn it into a modal surface
        { _HN log:equalTo { _X log:onModalSurface _GN } }
        # Else keep the triple
        { _HN log:equalTo _H }
    ) log:ifThenElseIn _Scope .

    ( _Acc ( _HN ) ) list:append _AccNew .

    (_T false _AccNew) :asModal_ _Lout .
} .

# on an odd surface we may replace a modal surface by a negative surface
(_X _Y _YN) log:onNegativeSurface {
    _X log:onNegativeSurface _Y .

    (_Y true) :asModal _YN .
    
    () log:onNegativeSurface {
        _X log:onNegativeSurface _YN .
    } .
} .

# on an even surface we may replace a negativesurface by a modal surface 
(_X _Y _YN) log:onNegativeSurface {
    _X log:onNegativeSurface _Y .
    
    (_Y true) :asModal _YN .

    () log:onNegativeSurface {
        _X log:onModalSurface _YN .
    } .
} .


