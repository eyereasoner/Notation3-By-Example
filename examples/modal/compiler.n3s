@prefix : <urn:example:> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix graph: <http://www.w3.org/2000/10/swap/graph#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .

# ( A Odd) asModal B
# Replace all nested surfaces into negative or modal according to the 
# nesting levels
#   A a graph
#   Odd true|false
#   B a graph with modals/negatives replaced
(?G1 ?G1L ?E ?G2 ?G2L) log:onNegativeSurface {
    () log:onNegativeSurface <<(?G1 ?E) :asModal ?G2>> .

    ?G1 graph:list ?G1L .

    # Creata an accumulator
    (?G1L ?E ()) :asModal_ ?G2L .

    ?G2 graph:list ?G2L .
} .

# We are done when the input is empty
(?E ?Acc) log:onNegativeSurface {
    () log:onNegativeSurface <<(() ?E ?Acc) :asModal_ ?Acc>> .
} .

# Process Odd = true
(?E ?Acc ?AccNew ?Lin ?Lout ?H ?T ?X ?G ?GN ?Scope ?HN) log:onNegativeSurface {
    () log:onNegativeSurface <<(?Lin ?E ?Acc) :asModal_ ?Lout>> .

    ?Lin list:firstRest (?H ?T) .

    # Odd is true
    ?E log:equalTo true .

    (
        # If we have a modal surface
        { 
            ?H log:includes { ?X log:onModalSurface ?G } .
            # Do the nested surfaces too
            ( ?G false ) :asModal ?GN .
        }
        # Then turn it into a negative surface
        { ?HN log:equalTo { ?X log:onNegativeSurface ?GN } }
        # Else keep the triple
        { ?HN log:equalTo ?H }
    ) log:ifThenElseIn ?Scope .

    ( ?Acc ( ?HN ) ) list:append ?AccNew .

    (?T true ?AccNew) :asModal_ ?Lout .
} .

# Process Odd = false
(?E ?Acc ?AccNew ?Lin ?Lout ?H ?T ?X ?G ?G2 ?GN ?Scope ?HN) log:onNegativeSurface {
    () log:onNegativeSurface <<(?Lin ?E ?Acc) :asModal_ ?Lout>> .

    ?Lin list:firstRest (?H ?T) .

    # Odd is true
    ?E log:equalTo false .

    (
        # If we have a negative surface
        { 
            ?H log:includes { ?X log:onNegativeSurface ?G } .
            # Do the nested surfaces too
            ( ?G true ) :asModal ?GN .    
        }
        # Then turn it into a modal surface
        { ?HN log:equalTo { ?X log:onModalSurface ?GN } }
        # Else keep the triple
        { ?HN log:equalTo ?H }
    ) log:ifThenElseIn ?Scope .

    ( ?Acc ( ?HN ) ) list:append ?AccNew .

    (?T false ?AccNew) :asModal_ ?Lout .
} .

# on an odd surface we may replace a modal surface by a negative surface
(?X ?Y ?YN) log:onNegativeSurface {
    ?X log:onNegativeSurface ?Y .

    (?Y true) :asModal ?YN .
    
    () log:onNegativeSurface {
        ?X log:onNegativeSurface ?YN .
    } .
} .

# on an even surface we may replace a negativesurface by a modal surface 
(?X ?Y ?YN) log:onNegativeSurface {
    ?X log:onNegativeSurface ?Y .
    
    (?Y true) :asModal ?YN .

    () log:onNegativeSurface {
        ?X log:onModalSurface ?YN .
    } .
} .


