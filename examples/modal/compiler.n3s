@prefix : <urn:example:> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix graph: <http://www.w3.org/2000/10/swap/graph#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .

# ( A Odd) asModal B
# Replace all nested surfaces into negative or modal according to the 
# nesting levels
#   A a graph
#   Odd true|false
#   B a graph with modals/negatives replaced
(_:G1 _:G1L _:E _:G2 _:G2L) log:onNegativeSurface {
    () log:onNegativeSurface <<(_:G1 _:E) :asModal _:G2>> .

    _:G1 graph:list _:G1L .

    # Creata an accumulator
    (_:G1L _:E ()) :asModal_ _:G2L .

    _:G2 graph:list _:G2L .
} .

# We are done when the input is empty
(_:E _:Acc) log:onNegativeSurface {
    () log:onNegativeSurface <<(() _:E _:Acc) :asModal_ _:Acc>> .
} .

# Process Odd = true
(_:E _:Acc _:AccNew _:Lin _:Lout _:H _:T _:X _:G _:GN _:Scope _:HN) log:onNegativeSurface {
    () log:onNegativeSurface <<(_:Lin _:E _:Acc) :asModal_ _:Lout>> .

    _:Lin list:firstRest (_:H _:T) .

    # Odd is true
    _:E log:equalTo true .

    (
        # If we have a modal surface
        { 
            _:H log:includes { _:X log:onModalSurface _:G } .
            # Do the nested surfaces too
            ( _:G false ) :asModal _:GN .
        }
        # Then turn it into a negative surface
        { _:HN log:equalTo { _:X log:onNegativeSurface _:GN } }
        # Else keep the triple
        { _:HN log:equalTo _:H }
    ) log:ifThenElseIn _:Scope .

    ( _:Acc ( _:HN ) ) list:append _:AccNew .

    (_:T true _:AccNew) :asModal_ _:Lout .
} .

# Process Odd = false
(_:E _:Acc _:AccNew _:Lin _:Lout _:H _:T _:X _:G _:G2 _:GN _:Scope _:HN) log:onNegativeSurface {
    () log:onNegativeSurface <<(_:Lin _:E _:Acc) :asModal_ _:Lout>> .

    _:Lin list:firstRest (_:H _:T) .

    # Odd is true
    _:E log:equalTo false .

    (
        # If we have a negative surface
        { 
            _:H log:includes { _:X log:onNegativeSurface _:G } .
            # Do the nested surfaces too
            ( _:G true ) :asModal _:GN .    
        }
        # Then turn it into a modal surface
        { _:HN log:equalTo { _:X log:onModalSurface _:GN } }
        # Else keep the triple
        { _:HN log:equalTo _:H }
    ) log:ifThenElseIn _:Scope .

    ( _:Acc ( _:HN ) ) list:append _:AccNew .

    (_:T false _:AccNew) :asModal_ _:Lout .
} .

# on an odd surface we may replace a modal surface by a negative surface
(_:X _:Y _:YN) log:onNegativeSurface {
    _:X log:onNegativeSurface _:Y .

    (_:Y true) :asModal _:YN .
    
    () log:onNegativeSurface {
        _:X log:onNegativeSurface _:YN .
    } .
} .

# on an even surface we may replace a negativesurface by a modal surface 
(_:X _:Y _:YN) log:onNegativeSurface {
    _:X log:onNegativeSurface _:Y .
    
    (_:Y true) :asModal _:YN .

    () log:onNegativeSurface {
        _:X log:onModalSurface _:YN .
    } .
} .

# A :asMergedModal B
# Merge all modal surfaces in A resulting in B
#   - A a graph term
#   - B a graph term
(_:G1 _:G2 _:G1L _:G2L) log:onNegativeSurface {
    () log:onNegativeSurface <<_:G1 :asMergedModal _:G2>> .

    _:G1 graph:list _:G1L .

    (_:G1L () ()) :asMergedModal_ _:G2L .

    _:G2 graph:list _:G2L .
} .

# At the end of the process we merge all modals and append it to the rest of the triples
(_:Acc _:Modals _:G _:Answer) log:onNegativeSurface {
    () log:onNegativeSurface <<(() _:Acc _:Modals) :asMergedModal_ _:Answer>> .

    _:Modals log:notEqualTo () .

    _:Modals graph:union _:G .

     ( ( { () log:onModalSurface _:G } ) _:Acc) list:append _:Answer .
} .

(_:Acc _:AccNew _:Modals _:ModalsNew _:Lin _:Lout _:H _:T _:X _:Y _:Z _:Scope) log:onNegativeSurface {
    () log:onNegativeSurface <<(_:Lin _:Acc _:Modals) :asMergedModal_ _:Lout>> .

    _:Lin list:firstRest (_:H _:T) .

    (
        # If we have a modal surface
        {
            _:H log:equalTo { _:X log:onModalSurface _:Y } .
        }
        # Then append to the modals
        {
            _:Y graph:list _:Z .

            # TODO What to do about the modal graffiti (?!)
            ( _:Modals _:Z ) list:append _:ModalsNew .
            _:AccNew log:equalTo _:Acc .
        }
        # Else append to the accumulator
        {
            ( _:Acc (_:H) ) list:append _:AccNew .
            _:ModalsNew log:equalTo _:Modals .
        }
    ) log:ifThenElseIn _:Scope .

    ( _:T _:AccNew _:ModalsNew) :asMergedModal_ _:Lout .
} .

# Merge nested modal surfaces on negative surfaces
(_:A _:B _:X) log:onNegativeSurface {
    _:X log:onNegativeSurface _:A .
    _:A :asMergedModal _:B .
    () log:onNegativeSurface {
        () log:onNegativeSurface _:B .
    } .
} .
