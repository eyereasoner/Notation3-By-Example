@prefix : <urn:example:> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix graph: <http://www.w3.org/2000/10/swap/graph#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .

# A :asMergedModal B
# Merge all modal surfaces in A resulting in B
#   - A a graph term
#   - B a graph term
(?G1 ?G2 ?G1L ?G2L) log:onNegativeSurface {
    () log:onNegativeSurface <<?G1 :asMergedModal ?G2>> .

    ?G1 graph:list ?G1L .

    (?G1L () ()) :asMergedModal_ ?G2L .

    ?G2 graph:list ?G2L .
} .

# At the end of the process we merge all modals and append it to the rest of the triples
(?Acc ?Modals ?G ?Answer) log:onNegativeSurface {
    () log:onNegativeSurface <<(() ?Acc ?Modals) :asMergedModal_ ?Answer>> .

    ?Modals log:notEqualTo () .

    ?Modals graph:union ?G .

     ( ( { () log:onModalSurface ?G } ) ?Acc) list:append ?Answer .
} .

(?Acc ?AccNew ?Modals ?ModalsNew ?Lin ?Lout ?H ?T ?X ?Y ?Z ?Scope) log:onNegativeSurface {
    () log:onNegativeSurface <<(?Lin ?Acc ?Modals) :asMergedModal_ ?Lout>> .

    ?Lin list:firstRest (?H ?T) .

    (
        # If we have a modal surface
        {
            ?H log:equalTo { ?X log:onModalSurface ?Y } .
        }
        # Then append to the modals
        {
            ?Y graph:list ?Z .

            # TODO What to do about the modal graffiti (?!)
            ( ?Modals ?Z ) list:append ?ModalsNew .
            ?AccNew log:equalTo ?Acc .
        }
        # Else append to the accumulator
        {
            ( ?Acc (?H) ) list:append ?AccNew .
            ?ModalsNew log:equalTo ?Modals .
        }
    ) log:ifThenElseIn ?Scope .

    ( ?T ?AccNew ?ModalsNew) :asMergedModal_ ?Lout .
} .

# Merge nested modal surfaces on negative surfaces
(?A ?B ?X) log:onNegativeSurface {
    ?X log:onNegativeSurface ?A .
    ?A :asMergedModal ?B .
    () log:onNegativeSurface {
        () log:onNegativeSurface ?B .
    } .
} .