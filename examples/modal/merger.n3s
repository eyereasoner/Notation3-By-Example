@prefix : <urn:example:> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix graph: <http://www.w3.org/2000/10/swap/graph#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .

# A :asMergedModal B
# Merge all modal surfaces in A resulting in B
#   - A a graph term
#   - B a graph term
(_G1 _G2 _G1L _G2L) log:onNegativeSurface {
    () log:onNegativeSurface <<_G1 :asMergedModal _G2>> .

    _G1 graph:list _G1L .

    (_G1L () ()) :asMergedModal_ _G2L .

    _G2 graph:list _G2L .
} .

# At the end of the process we merge all modals and append it to the rest of the triples
(_Acc _Modals _G _Answer) log:onNegativeSurface {
    () log:onNegativeSurface <<(() _Acc _Modals) :asMergedModal_ _Answer>> .

    _Modals log:notEqualTo () .

    _Modals graph:union _G .

     ( ( { () log:onModalSurface _G } ) _Acc) list:append _Answer .
} .

(_Acc _AccNew _Modals _ModalsNew _Lin _Lout _H _T _X _Y _Z _Scope) log:onNegativeSurface {
    () log:onNegativeSurface <<(_Lin _Acc _Modals) :asMergedModal_ _Lout>> .

    _Lin list:firstRest (_H _T) .

    (
        # If we have a modal surface
        {
            _H log:equalTo { _X log:onModalSurface _Y } .
        }
        # Then append to the modals
        {
            _Y graph:list _Z .

            # TODO What to do about the modal graffiti (?!)
            ( _Modals _Z ) list:append _ModalsNew .
            _AccNew log:equalTo _Acc .
        }
        # Else append to the accumulator
        {
            ( _Acc (_H) ) list:append _AccNew .
            _ModalsNew log:equalTo _Modals .
        }
    ) log:ifThenElseIn _Scope .

    ( _T _AccNew _ModalsNew) :asMergedModal_ _Lout .
} .

# Merge nested modal surfaces on negative surfaces
(_A _B _X) log:onNegativeSurface {
    _X log:onNegativeSurface _A .
    _A :asMergedModal _B .
    () log:onNegativeSurface {
        () log:onNegativeSurface _B .
    } .
} .