@prefix : <https://github.com/eyereasoner/Notation3-By-Example/example/n3l#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix graph: <http://www.w3.org/2000/10/swap/graph#> .

# Find all log:RDFSurface and compile them into blogic
(?N ?F ?X) log:onNegativeSurface {
    ?N a log:RDFSurface ;
        rdf:value ?F .
    ?F :asSurface ?X .
    () log:onNegativeSurface ?X . 
} .

# List :asSurface Blogic
#  returns the List as Blogic graph
(?F ?G) log:onNegativeSurface {
    () log:onNegativeSurface <<?F :asSurface ?G>> .
    # We use an accumulator to construct the graph
    (?F ()) :_asSurface ?G . 
} .

# When the list is empty we are done with accumulating and return the result
(?Acc) log:onNegativeSurface {
    () log:onNegativeSurface <<(() ?Acc) :_asSurface ?Acc>> .
} .

# Peak into the list if we see a blogic type list, that gathering the subgraph defined in it
(?F ?Acc ?N ?G ?A ?B ?Type ?Rest ?Graph) log:onNegativeSurface {
    () log:onNegativeSurface <<(?F ?Acc) :_asSurface ?G>> .
    
    ?F list:length ?N .
    ?N math:greaterThan 0 .

    # Peek what we have in the list
    ( (?A ?B) ?Rest ) list:append ?F .    

    # Test if it is blogic like...
    ?A list:in ( log:neg log:pos log:query log:construct ) .

    # Find the subgraph of the rest
    ?Rest :asGraph ?Graph .

    # Construct the surface...
    (?A ?B ?Graph) :makeSurface ?G .
} .

# Construct the graphs we need..
(?Param ?Graph ?Blogic) log:onNegativeSurface {
    () log:onNegativeSurface <<(log:neg ?Param ?Graph) :makeSurface ?Blogic>> .
    ( () { ?Param log:onNegativeSurface ?Graph }) :_asSurface ?Blogic .
} .

(?Param ?Graph ?Blogic) log:onNegativeSurface {
    () log:onNegativeSurface <<(log:pos ?Param ?Graph) :makeSurface ?Blogic>> .
    ( () { ?Param log:onPositiveSurface ?Graph }) :_asSurface ?Blogic .
} .

(?Param ?Graph ?Blogic) log:onNegativeSurface {
    () log:onNegativeSurface <<(log:query ?Param ?Graph) :makeSurface ?Blogic>> .
    ( () { ?Param log:onQuerySurface ?Graph }) :_asSurface ?Blogic .
} .

(?Param ?Graph ?Blogic) log:onNegativeSurface {
    () log:onNegativeSurface <<(log:construct ?Param ?Graph) :makeSurface ?Blogic>> .
    ( () { ?Param log:onQuerySurface ?Graph }) :_asSurface ?Blogic .
} .

# List :asGraph Formula
#  given a list of 3 return a graph
(?L ?Graph ?Temp) log:onNegativeSurface {
    () log:onNegativeSurface <<?L :asGraph ?Graph>> .
    (?L ()) :_asGraph ?Temp .
    ?Graph graph:list ?Temp .
} .

(?Acc) log:onNegativeSurface {
    () log:onNegativeSurface <<( () ?Acc) :_asGraph ?Acc>> .
} .

(
   ?L ?Acc ?Graph 
   ?Head ?Tail ?Peek
   ?N ?S ?P ?O ?Rest ?AccNew ?Surface
   ?Scope
) log:onNegativeSurface {
    () log:onNegativeSurface <<(?L ?Acc) :_asGraph ?Graph>> .

    ?L list:length ?N .
    ?N math:greaterThan 0 .

    ?L list:firstRest (?Head ?Tail) . 

    # If we have a log:neg, then create a nested log:neg otherwise
    # continue building the graph
    (
       # if
       {
         # Check if the head is a list with a log:neg

         ?Head log:rawType rdf:List .
         ?Head list:first ?Peek .
         ?Peek list:in (log:neg log:pos log:query log:construct) .
       }
       # then
       {
            ?Head :asSurface ?Surface .            
            ( ?Acc ( ?Surface ) ) list:append ?AccNew .
            ( ?Tail ?AccNew ) :_asGraph ?Graph .
       }  
       # else 
       {
            ( (?S ?P ?O) ?Rest ) list:append ?L . 

            # Append this as new triple graph to the accumulator
            ( ?Acc ( { ?S ?P ?O } ) ) list:append ?AccNew .
            ( ?Rest ?AccNew ) :_asGraph ?Graph .
       }
    ) log:ifThenElseIn ?Scope .
} .
