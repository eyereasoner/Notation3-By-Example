@prefix : <https://example.org/ns/>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix acl: <http://www.w3.org/ns/auth/acl#>.
@prefix string: <http://www.w3.org/2000/10/swap/string#>.
@prefix dc: <http://purl.org/dc/terms/>.
@prefix ldp: <http://www.w3.org/ns/ldp#>.
@prefix posix: <http://www.w3.org/ns/posix/stat#>.
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.
@prefix foaf: <http://xmlns.com/foaf/0.1/>.
@prefix solid: <http://www.w3.org/ns/solid/terms#>.
@prefix space: <http://www.w3.org/ns/pim/space#>.
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix vcard: <http://www.w3.org/2006/vcard/ns#>.
@prefix pim: <http://www.w3.org/ns/pim/space#>.

@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix graph: <http://www.w3.org/2000/10/swap/graph#> .

@prefix pol:  <https://www.example.org/ns/policy#> .

# This rule looks at which data can be returned


(
    _:Resource _:ResourceACL
    _:ResourceACLGraph
    _:Authorization
    _:G
    _:S _:P _:O

    _:AccessStatusGraph _:DenialStatusGraph
    _:AccessGrant _:AccessDenial
    _:AccessDenialComment
    _:AD_S _:AD_P _:AD_O
    _:Scope
    _:AssertSurface
) log:onNegativeSurface {

    # Extract the requested Resource
    :RequestContext acl:resource _:Resource.
    # ...and the requested access mode
    :RequestContext acl:mode acl:Read.

    # If the resource contains a phone number triple:
    <<() log:onNeutralSurface _:G>> :partOf _:Resource.
    _:G log:includes { _:S _:P _:O }.


    # () log:onNeutralSurface {
    #     _:AccessDenial a :AccessDenial;
    #         acl:agentClass foaf:Agent;
    #         acl:accessTo _:Resource;
    #         acl:mode acl:Read;
    #         acl:managingACLDocument _:ResourceACl;
    #         acl:conflict << _:Person foaf:phone _:PhoneNumberLiteral >> ;
    #         acl:comment "Denial of resource access because of conflict in triple based access."
    # } {| pol:context :SolidAccessDenial|}

    # NOTE: We have to do both here, else it tries to find a neutral surface 
    # ... that both contains an Access AND a Denial, which may not Exist as a single surface!

    # We stop the rule if we do not have an access grant for the resource

    # Note that here we assume these are on the same neutral surface in this context.!
    # Ideally we should use a built-in that collects all graphs with the same context into one!
    _:AccessGrant a :AccessGrant;
        acl:accessTo _:Resource;
        acl:mode acl:Read.


    # We put all triples of the resource on the data surface that are not explicitly denied by an access denial

    (
        # if
        { 
            _:AccessDenial a :AccessDenial;
                acl:accessTo _:Resource;
                acl:mode acl:Read;
                # Check if the triple matches
                acl:conflict << _:S _:P _:O >>;
                acl:comment _:AccessDenialComment.
        }
        # then - on a matching triple, we want to NOT write the triple!
        { 
            _:AssertSurface log:equalTo {
                () log:onMetadataSurface {
                    << _:S _:P _:O >> 
                        :status :Denied;
                        :cause  _:AccessDenialComment;
                        :fromResource _:Resource;
                        :access _:AccessStatusGraph;
                        :denial _:DenialStatusGraph.
                }.
            }.
        }
        # else
        { 
            _:AssertSurface log:equalTo {
                () log:onDataSurface {
                    _:S _:P _:O .
                }.
                () log:onMetadataSurface {
                    << _:S _:P _:O >> 
                        :status :Returned;
                        :fromResource _:Resource;
                        :access _:AccessStatusGraph;
                        :denial _:DenialStatusGraph.
                }.
            }.
        }
    ) log:ifThenElseIn _:Scope.


    # () log:onNegativeSurface { () log:onLogSurface _:AccessStatusGraph } .
    () log:onNegativeSurface _:AssertSurface.

    # () log:onNegativeSurface {
    #     () log:onDataSurface {
    #         _:S _:P _:O.
    #     }
    # }.

}.
