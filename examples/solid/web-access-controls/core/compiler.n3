@prefix : <https://example.org/ns/> .
@prefix pol:  <https://www.example.org/ns/policy#> .
@prefix util: <https://github.com/phochste/util#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix graph: <http://www.w3.org/2000/10/swap/graph#>.
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.

# Search for a pol:Rule 
#  pol:body holds the logic of the rule
#  ... pol:when select on what conditions the rule should be executed
#  ... pol:then* describes what should happen when the condition holds
(  _:Rule _:Body 
   _:Param _:WhenBody _:ThenBody
   _:WhenBodyPrime
) log:onNegativeSurface {
    # Select all rules with a body
    _:Rule a pol:Rule , pol:ValidRule ;
        pol:body _:Body .

    # The body should contain a `when` and possible multiple `then`-s.
    _:Body log:includes {
        _:Param pol:when _:WhenBody ;
                pol:then _:ThenBody .
    } .

    # Create the body of a new negative surface implication. The
    # `when` triples will be the head and the `then` triples the body
    # of the implication: HEAD -> BODY
    ( _:WhenBody {
        () log:onNegativeSurface _:ThenBody .
    }) log:conjunction _:WhenBodyPrime .

    # Execute the new negative surface implication rules
    () log:onNegativeSurface {
        _:Param log:onNegativeSurface _:WhenBodyPrime.
    } .
} .


# Search for a pol:Rule 
#  pol:body holds the logic of the rule
#  ... pol:when select on what conditions the rule should be executed
#  ... pol:thenNot* describes what should not happen when the condition holds
(  _:Rule _:Body 
   _:Param _:WhenBody _:ThenNotBody
   _:WhenBodyPrime
) log:onNegativeSurface {
    # Select all rules with a body
    _:Rule a pol:Rule , pol:ValidRule ;
        pol:body _:Body .

    # The body should contain a `when` and possible multiple `thenNot`-s.
    _:Body log:includes {
        _:Param pol:when _:WhenBody ;
                pol:thenNot _:ThenNotBody .
    } .

    # Create the body of a new negative surface implication. The
    # `when` triples will be the head and the `then` triples the body
    # of the implication: HEAD -> BODY
    ( _:WhenBody {
        () log:onPositiveSurface _:ThenNotBody .
    }) log:conjunction _:WhenBodyPrime .

    # Execute the new negative surface implication rules
    () log:onNegativeSurface {
        _:Param log:onNegativeSurface _:WhenBodyPrime .
    } .
} .


####################
# Helper functions #
####################

# ( _:Logger _:G _:Rule ) log:onNegativeSurface {
#     _:Logger pol:rule _:Rule.
#     _:Logger pol:log _:G.
#     () log:onNegativeSurface {
#         () log:onLogSurface _:G .# {| pol:fromRule _:Rule |}.
#     }.
# }.


# Logging Rule
( _:Logger _:G _:Rule _:Label ) log:onNegativeSurface {
    _:Logger a pol:Logger.
    _:Logger pol:log _:G.
    _:Logger pol:rule _:Rule.
    _:Rule rdfs:label _:Label.
    () log:onNegativeSurface {
        () log:onLogSurface {
            _:Logger a pol:Logger.
            _:Logger pol:rule _:Rule.
            _:Rule rdfs:label _:Label.
            _:Logger pol:log _:G.
        }.
    }.
}.

