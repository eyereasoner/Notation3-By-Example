@prefix : <https://example.org/ns/>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix acl: <http://www.w3.org/ns/auth/acl#>.
@prefix string: <http://www.w3.org/2000/10/swap/string#>.
@prefix dc: <http://purl.org/dc/terms/>.
@prefix ldp: <http://www.w3.org/ns/ldp#>.
@prefix posix: <http://www.w3.org/ns/posix/stat#>.
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.
@prefix foaf: <http://xmlns.com/foaf/0.1/>.
@prefix solid: <http://www.w3.org/ns/solid/terms#>.
@prefix space: <http://www.w3.org/ns/pim/space#>.
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix vcard: <http://www.w3.org/2006/vcard/ns#>.
@prefix pim: <http://www.w3.org/ns/pim/space#>.

@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix graph: <http://www.w3.org/2000/10/swap/graph#> .

@prefix pol:  <https://www.example.org/ns/policy#> .

# We want to precomute all accesses on all resources
# without relying on specific slash semantics -> optional?
# we support
# - acl:mode:
#   - acl:read
#   - acl:write
#   - acl:append
#   - acl:control
# - acl:Agent <webid>
# - acl:AgentClass foaf:Agent
# - acl:accessTo <resourceURI>
# - acl:default <containerURI>

# The following predicates are expected:

# main surface:
# - :acl - defines a connection between a resource and its ACL 
# - ldp:contains - defines a parent relation between a container and a contained resource
# - :ACLSource - defines the resource type for ACLs
# - :MetaSource - defines the resource type for auxiliary resources

# The following predicates are defined by this policy:

# main surface:
# - :inheritsACL - defines the inherited ACL for a resource
# - :hasConnectedACL - defines the connected ACL, be it inherited or a direct link

################################
# Connecting the ACL resources #
################################


# Assign connected ACL document.

:Rule_Annotate_Connected_ACL a pol:Rule ;
    rdfs:label "Assign directly linked ACL document as ResourceACL";
    pol:body { 
        (
            _:Resource _:ResourceACL 
        ) 
            # When we have a resource with a directly connected ACL
            pol:when {
                _:Resource a ldp:Resource.
                _:Resource :acl _:ResourceACL.
            } ;
            # ... annotate it as such
            pol:then {
                _:Resource :hasConnectedACL _:ResourceACL.
                
                _:Logger a pol:Logger;
                    pol:rule :Rule_Annotate_Connected_ACL;
                    pol:log {     
                    _:Resource :hasConnectedACL _:ResourceACL.
                }.
            } .
    } .



# Inherit ACL from parent resource ACL if no own ACL resource.
:Rule_Find_Parent_ACL a pol:Rule ;
    rdfs:label "Find resource ACL through parent resource.";
    pol:body { 
        (
            _:Resource _:ResourceACL
            _:ParentResource _:ParentResourceACL
            _:Scope
        )
            pol:when {
                () log:onPositiveSurface {
                    # We look in the main surface, as resource connections is authoritative data, and NOT on a neutral surface!
                    # We make use of a forward-chaining approach here
                    _:Resource a ldp:Resource.
                    _:ParentResource ldp:contains _:Resource.
                    _:ParentResource :hasConnectedACL _:ParentResourceACL.

                    # Check if resource has own ACL 
                    ({ _:Resource :acl _:ResourceACL } false true) log:ifThenElseIn _:Scope.
                    # And if the resource itself is NOT an ACL resource
                    ({ _:Resource a :ACLSource } false true) log:ifThenElseIn _:Scope.
                    # And if the resource itself is NOT a metadata resource
                    ({ _:Resource a :METASource } false true) log:ifThenElseIn _:Scope.
                }
            } ;

            pol:then {
                _:Resource :inheritsACL _:ParentResourceACL.
                _:Resource :hasConnectedACL _:ParentResourceACL.

                _:Logger a pol:Logger;
                    pol:rule :Rule_Find_Parent_ACL;
                    pol:log {    
                    _:Resource :inheritsACL _:ParentResourceACL.
                    _:Resource :hasConnectedACL _:ParentResourceACL.
                }.
            } ;
    } .

# Inherit metadata ACL from resource ACL
:Rule_Find_Metadata_ACL a pol:Rule ;
    rdfs:label "Inherit metadata ACL from resource ACL";
    pol:body { 
        (
            _:Resource _:ResourceACL
            _:MetaResource 
            _:Scope
        )
            pol:when {
                () log:onPositiveSurface {
                    # We look in the main surface, as resource connections is authoritative data, and NOT on a neutral surface!
                    # We make use of a forward-chaining approach here
                    _:Resource a ldp:Resource.
                    _:Resource :describedby _:MetaResource.

                    _:Resource :hasConnectedACL _:ResourceACL.
                }
            } ;
            
            pol:then {
                _:MetaResource :inheritsACL _:ResourceACL.
                _:MetaResource :hasConnectedACL _:ResourceACL.

                _:Logger a pol:Logger;
                    pol:rule :Rule_Find_Metadata_ACL;
                    pol:log { 
                    _:MetaResource :inheritsACL _:ResourceACL.
                    _:MetaResource :hasConnectedACL _:ResourceACL.
                
                }.
            } .
        } .
