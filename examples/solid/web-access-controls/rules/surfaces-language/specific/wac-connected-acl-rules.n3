@prefix : <https://example.org/ns/>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix acl: <http://www.w3.org/ns/auth/acl#>.
@prefix string: <http://www.w3.org/2000/10/swap/string#>.
@prefix dc: <http://purl.org/dc/terms/>.
@prefix ldp: <http://www.w3.org/ns/ldp#>.
@prefix posix: <http://www.w3.org/ns/posix/stat#>.
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.
@prefix foaf: <http://xmlns.com/foaf/0.1/>.
@prefix solid: <http://www.w3.org/ns/solid/terms#>.
@prefix space: <http://www.w3.org/ns/pim/space#>.
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix vcard: <http://www.w3.org/2006/vcard/ns#>.
@prefix pim: <http://www.w3.org/ns/pim/space#>.

@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix graph: <http://www.w3.org/2000/10/swap/graph#> .

@prefix pol:  <https://www.example.org/ns/policy#> .

# We want to precomute all accesses on all resources
# without relying on specific slash semantics -> optional?
# we support
# - acl:mode:
#   - acl:read
#   - acl:write
#   - acl:append
#   - acl:control
# - acl:Agent <webid>
# - acl:AgentClass foaf:Agent
# - acl:accessTo <resourceURI>
# - acl:default <containerURI>

# The following predicates are expected:

# main surface:
# - :acl - defines a connection between a resource and its ACL 
# - ldp:contains - defines a parent relation between a container and a contained resource
# - :ACLSource - defines the resource type for ACLs
# - :MetaSource - defines the resource type for auxiliary resources

# The following predicates are defined by this policy:

# main surface:
# - :inheritsACL - defines the inherited ACL for a resource
# - :hasConnectedACL - defines the connected ACL, be it inherited or a direct link

################################
# Connecting the ACL resources #
################################

# Inherit ACL from parent resource ACL if no own ACL resource.
(
    _:Resource _:ResourceACL
) log:onNegativeSurface {
    () log:onPositiveSurface {
        _:Resource a ldp:Resource.
        _:Resource :acl _:ResourceACL.
    }.
    () log:onNegativeSurface {
        _:Resource :hasConnectedACL _:ResourceACL.
        () log:onLogSurface {     
            << _:Resource :hasConnectedACL _:ResourceACL >> :accordingTo "DirectACLRule".
        }.
    }.
}.


# Inherit ACL from parent resource ACL if no own ACL resource.
(
    _:Resource _:ResourceACL
    _:ParentResource _:ParentResourceACL
    _:Scope
) log:onNegativeSurface {
    () log:onPositiveSurface {
        # We look in the main surface, as resource connections is authoritative data, and NOT on a neutral surface!
        # We make use of a forward-chaining approach here
        
        _:Resource a ldp:Resource.
        _:ParentResource ldp:contains _:Resource.
        _:ParentResource :acl _:ParentResourceACL.
        # Check if resource has own ACL 
        ({ _:Resource :acl _:ResourceACL } false true) log:ifThenElseIn _:Scope.
        # And if the resource itself is NOT an ACL resource
        ({ _:Resource a :ACLSource } false true) log:ifThenElseIn _:Scope.
        # And if the resource itself is NOT a metadata resource
        ({ _:Resource a :METASource } false true) log:ifThenElseIn _:Scope.
    }.

    () log:onNegativeSurface {
        _:Resource :inheritsACL _:ParentResourceACL.
        _:Resource :hasConnectedACL _:ParentResourceACL.
        () log:onLogSurface {     
            << _:Resource :inheritsACL _:ParentResourceACL >> :accordingTo "InheritFromDirectACLRule".
            << _:Resource :hasConnectedACL _:ParentResourceACL >> :accordingTo "InheritFromDirectACLRule".
        }.
    }.
}.


# Inherit ACL from parent resource inherited ACL if no own ACL resource.
(
    _:Resource _:ResourceACL
    _:ParentResource _:ParentResourceACL
    _:Scope
) log:onNegativeSurface {
    () log:onPositiveSurface {
        # We look in the main surface, as resource connections is authoritative data, and NOT on a neutral surface!
        # We make use of a forward-chaining approach here
        
        _:Resource a ldp:Resource.
        _:ParentResource ldp:contains _:Resource.
        _:ParentResource :inheritsACL _:ParentResourceACL.
        # Check if resource has own ACL 
        ({ _:Resource :acl _:ResourceACL } false true) log:ifThenElseIn _:Scope.
        # And if the resource itself is NOT an ACL resource
        ({ _:Resource a :ACLSource } false true) log:ifThenElseIn _:Scope.
        # And if the resource itself is NOT a metadata resource
        ({ _:Resource a :MetaSource } false true) log:ifThenElseIn _:Scope.
    }.

    () log:onNegativeSurface {
        _:Resource :inheritsACL _:ParentResourceACL.
        _:Resource :hasConnectedACL _:ParentResourceACL.
        () log:onLogSurface {     
            << _:Resource :inheritsACL _:ParentResourceACL >> :accordingTo "InheritFromInheritedACLRule".
            << _:Resource :hasConnectedACL _:ParentResourceACL >> :accordingTo "InheritFromInheritedACLRule".
        }.
    }.
}.

# Inherit metadata ACL from resource ACL
(
    _:Resource _:ResourceACL
    _:MetaResource 
    _:Scope
) log:onNegativeSurface {
    () log:onPositiveSurface {
        # We look in the main surface, as resource connections is authoritative data, and NOT on a neutral surface!
        # We make use of a forward-chaining approach here
        
        _:Resource a ldp:Resource.
        _:Resource :describedby _:MetaResource.

        _:Resource :acl _:ResourceACL.
    }.

    () log:onNegativeSurface {
        _:MetaResource :inheritsACL _:ResourceACL.
        _:MetaResource :hasConnectedACL _:ResourceACL.
        () log:onLogSurface {     
            << _:MetaResource :inheritsACL _:ResourceACL >> :accordingTo "MetadataInheritanceRule".
            << _:MetaResource :hasConnectedACL _:ResourceACL >> :accordingTo "MetadataInheritanceRule".
        
        }.
    }.
}.


# Inherit metadata ACL from resource inherited ACL
(
    _:Resource _:ResourceACL
    _:MetaResource 
    _:Scope
) log:onNegativeSurface {
    () log:onPositiveSurface {
        # We look in the main surface, as resource connections is authoritative data, and NOT on a neutral surface!
        # We make use of a forward-chaining approach here
        
        _:Resource a ldp:Resource.
        _:Resource :describedby _:MetaResource.

        _:Resource :inheritsACL _:ResourceACL.
    }.

    () log:onNegativeSurface {
        _:MetaResource :inheritsACL _:ResourceACL.
        _:MetaResource :hasConnectedACL _:ResourceACL.
        () log:onLogSurface {     
            << _:MetaResource :inheritsACL _:ResourceACL >> :accordingTo "MetadataInheritFromInheritedACLRule".
            << _:MetaResource :hasConnectedACL _:ResourceACL >> :accordingTo "MetadataInheritFromInheritedACLRule".
        }.
    }.
}.