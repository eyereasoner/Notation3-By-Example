@prefix : <urn:example.org:> .
@prefix odrl: <http://www.w3.org/ns/odrl/2/> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .

# Check if the ODRL policies are valid. This is true when
# all constrains are valid (in our example)

(?Policy ?Permission ?Constraint ?LO ?O ?RO ?Validity ?Scope) log:onNegativeSurface {

    # Gather all the metadata of the policy
    ?Policy a odrl:Offer .
    ?Policy odrl:permission ?Permission .
    ?Permission odrl:constraint ?Constraint .

    # This matches logical constraints that are in the policy
    ?Constraint odrl:leftOperand ?LO .
    ?Constraint odrl:operator ?O .
    ?Constraint odrl:rightOperand ?RO .

    # Using the experimental ifThenElseIn built-in to
    # execute the logical contraint (see below for an
    # implementation using backward rules)
    ( 
      # if 
      {?LO ?O ?RO} 
      # then
      {?Validity log:equalTo :Satisfied} 
      # else 
      {?Validity log:equalTo :NotSatisfied}
    ) log:ifThenElseIn ?Scope.

    () log:onNegativeSurface {
        ?Constraint :is ?Validity .
    } .
} .

# Implementation of an odrl:lt checker for dates
(?Blank ?CurrentDate ?Date) log:onNegativeSurface {
    () log:onNegativeSurface <<odrl:dateTime odrl:lt ?Date>> .
    ?Blank :currentDate ?CurrentDate  .
    ?CurrentDate string:lessThan ?Date .
} .

# Implementation of an odrl:gt checker for dates
(?Blank ?CurrentDate ?Date) log:onNegativeSurface {
    () log:onNegativeSurface <<odrl:dateTime odrl:gt ?Date>> .
    ?Blank :currentDate ?CurrentDate  .
    ?CurrentDate string:greaterThan ?Date .
} .

# A policy is valid when all the contraints are valid 
(?Policy ?Permission ?Constraint ?Validity ?Scope ?Scope2) log:onNegativeSurface {
    ?Policy a odrl:Offer .
    ?Policy odrl:permission ?Permission .
    
    (
        # if
        {
            # All constraints are valid ..
            ( 
                { ?Permission odrl:constraint ?Constraint }
                { ?Constraint :is :Satisfied } 
            ) log:forAllIn ?Scope .
        }
        # then
        {  ?Validity log:equalTo :Satisfied } 
        {  ?Validity log:equalTo :NotSatisfied }
    ) log:ifThenElseIn ?Scope .

    () log:onNegativeSurface {
        ?Policy :is ?Validity .
    } .
} .

# Show something on the output
(?S ?P ?O) log:onQuestionSurface {
    ?S ?P ?O .
    ?P log:notEqualTo log:onNegativeSurface .
    ?P log:notEqualTo log:onQuestionSurface .
    () log:onAnswerSurface {
        ?S ?P ?O .
    } .
} .
